#!/bin/bash


# repositorizer
# Version: 2.2
# Author: monon


## Script output format variables
SCRIPT_NAME=$(basename $0)
[[ -e ${HOME}/.bash_colors ]] && source ${HOME}/.bash_colors
BD=${BOLD}
NL=${NORMAL}
RD=${RED}
GN=${GREEN}
WARNING="${BD}${RD}Warning!${NL}:"

## Global Variables 
REMOTE_USER=""
REMOTE_HOST=""
REMOTE_PORT=""
REMOTE_DESTINATION=""
DEST_REPO="" ## Carpeta destino del repositorio
ORIG_PACKAGES="" ## Carpeta origen de los paquetes
MOUNTPOINT="/tmp/repositorizer/"
OPTS_SAVED_FILE="/.config/repositorizerrc"
MAX_SAVED=8


OPT_REMOTE=""
OPT_ORIGEN=""
OPT_DESTINATION=""

DISTRIBUTIONS_TEXT=$(cat <<EOF

Origin: (domain.org)
Label: (Description label)
Suite: (codename)
Version: (numeral version XX.XX)
Codename: (codename)
Architectures: (amd64 i386 etc)
Components: (main non-free etc)
Description: (Full description)
SignWith: (Last eight digit of key XXXXXXXX)

EOF
)

function mssg_exit()
{
    echo -e "${BD}Saliendo!${NL}"
}

## Funciones de mensajes
function mssg_error()
{
    local message=$(echo -e ${1} | sed -e "s|^ \+\(.\+\)|          \1|")
    echo -e "${WARNING} ${message}"
}


function mssg()
{
    local message=$(echo -e "${1}" | sed -e "s|^ \+\(.\+\)$|    \1|")
    echo -e "$message"
}


function mssg_ask()
{
    local message=$(echo -e "${1}" | sed -e "s|^ \+\(.\+\)$|    \1|")
    echo -ne "$message"
}


## Valida el argumento de la opcion -r servidor remoto
function validate_remote()
{
    local user
    local host
    local port

    pattern="^[[[:alnum:]_-]+@[[:alnum:]_-]+\.[[:alnum:]_-]+[0-9:]*$"
    if [[ ! ${1} =~ ^-. ]] && [[ ${1} =~ ${pattern}$ ]]; then
        user=$(echo ${1} | sed -e "s|\(^[[:alnum:]_-]\+\)@.\+$|\1|")
        host=$(echo ${1} | sed -e "s|^.\+@\([[:alnum:]_-]\+\.[[:alnum:]_-]\+\)[:][[:digit:]]*|\1|")
        port=$(echo ${1} | sed -e "/.\+:.\+/!d" -e "s|^.\+:\([[:digit:]]*$\)|\1|g")
        [[ -z $port ]] && port="22"
        REMOTE_USER="${user}"
        REMOTE_HOST="${host}"
        REMOTE_PORT="${port}"
        mssg "${BD}Host remoto${NL}\n\
              ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_PORT}"
    else
        mssg_error "El host remoto ${BD}${1}${NL} està mal formado\n\
                    Formato: ${BD}user@host.domain:[port]${NL}"
        echo
        exit 1
    fi
    echo
    return 0
}


## Valida el argumento de la opcion -i clave ssh
function validate_identity()
{
    if [[ -z ${1} ]] ; then
        mssg_error "El archivo clave ssh no esta definido"
        echo
        exit 1
     elif [[ ! -e ${1} ]]; then
        mssg_error "La clave ssh no es valida"
        echo
        exit 1
     else
        IDENTITY="${1}"
        mssg "${BD}Clave ssh${NL}\n\
              ${IDENTITY}"
    fi
    echo
    return 0
}


## Valida el argumento de la opcion -p directorio origen de las vesiones de paquetes
function validate_origen_packages()
{
    if [[ -z ${1} ]] ; then
        mssg_error "Directorio origen de los paquetes no esta definido"
        echo
        exit 1
     elif [[ ! -d ${1} ]]; then
        mssg_error "El origen de paquetes no es un directorio"
        echo
        exit 1
     else
        ORIG_PACKAGES="${1}"
        mssg "${BD}Origen de paquetes${NL}\n\
              ${ORIG_PACKAGES}"
    fi
    echo
    return 0
}


## Valida el argumento principal directorio destino del repositorio
function validate_destination_repositori()
{
    local input_read
    
    mssg "${BD}Repositorio destino${NL} (Working directory)"
    if [[ -n ${1} ]] ; then
        
        if [[ ! -d ${1} ]] ; then 
            mssg_error "Es necesario una ruta al repositorio de destino."
        fi
        DEST_REPO="${1}"

        [[ $? -eq 0 ]] ||  ( echo ; exit 1 )

        if [[ ! -e ${DEST_REPO} ]] ; then
            mssg_error "El directorio ${BD}${DEST_REPO}${NL} no existe."
            mssg_ask "${GN}${SCRIPT_NAME}${NL}: Crear directorio? ${BD}[y/N]${NL}:"
            read -sn1 input_read
            echo
            if [[ "${input_read}" =~ ^[YySs]$ ]] ; then
                mssg "${BD}Creando directorio"
                mkdir -p ${DEST_REPO} || ( echo ; exit 1 )
            else
                mssg_exit
                echo
                exit 0
            fi
        fi

        if [[ ! -d ${DEST_REPO} ]]; then
            mssg_error "El destino debe ser un directorio!"
            echo
            exit 1
        else
            mssg "    ${DEST_REPO}"
            if [[ ! -n ${ORIG_PACKAGES} ]] && [[ ! -d ${ORIG_PACKAGES} ]]; then
                mssg_error "Directorio origen de los paquetes es incorrecto."
                echo
                exit 1 
            fi
        fi
    fi
    echo
    return 0
}


## Elimina paquetes del repositorio.
function remove_packages()
{
    local codename=${1}
    local arch="amd64"
    reprepro -A ${arch} --list-format  '${package} ' list ${codename} 1> /dev/null
    if [[ ! ${?} -eq 0 ]] ; then
        mssg_error "Es posible que haya errores de formato en el archivo ${BD}distributions${NL}"
        echo
        exit 1
    fi
    local package_list=$(reprepro -A ${arch} --list-format  '${package} ' list ${codename})
    local package_from_repo
     
    mssg "Eliminando paquetes no referenciados en:\n\
                                            ${ORIG_PACKAGES}/${codename}\n"
    mssg "Checking..."
    for package in ${package_list}  ; do # Itera la lista de "Nombres" de paquetes
        PKG_DEB=$(reprepro -A ${arch} --list-format '${package}_${version}_${architecture}.deb\n' \
                listmatched ${codename} "${package}" 2> /dev/null | sed -e "s/[0-9]://")
        
        if [[ ! -e "${ORIG_PACKAGES}/${codename}/${PKG_DEB}" ]] ; then 
            mssg "${BD}${RD}Eliminando del repositorio...${NL}\n\
                     ${BD}${RD}    ${PKG_DEB}${NL}"
            reprepro remove ${codename} ${package} > /dev/null
        else
            mssg "    ${PKG_DEB}"
        fi
    done
    return 0
}


## Añade paquetes al repositorio
function add_packages()
{
    local codename=${1}
    local command_output
    
    mssg "Añadiendo paquetes para ${BD}\"${codename}\"${NL} desde:\n\
                                                ${ORIG_PACKAGES}/${codename}\n"
    mssg "Checking..."
    for DEB in ${ORIG_PACKAGES}/${codename}/*.deb ; do 
        DEB=$(echo ${DEB} | sed -e "s/[0-9]://")
        ## Si no funciona añadir  --ask-passphrase
        command_output=$(reprepro -V -A amd64 --ask-passphrase \
            -b . includedeb ${codename} ${DEB}  2> /dev/null \
            || reprepro -V -A amd64 -S utils -P optional --ask-passphrase \
            -b . includedeb ${codename} ${DEB} 2> /dev/null)
        if [[ ! $? -eq 0 ]] ; then
            mssg_error "Es posible que haya errores en el archivo distributions\n\
                                    o  con algun paquete"
            echo
            exit 1
        fi
        if [[ $(echo -e "${command_output}") =~ Created ]]; then
            mssg "${GN}Añadiendo...${NL}
                  ${GN}$(basename ${DEB})${NL}"
        else 
            mssg "    $(basename ${DEB})"
        fi
    done
    return 0
}


## Actualiza el repositorio 
function update_repository()
{
    local input_read
    declare -a suitables
    
    cd ${DEST_REPO} ## Changing working directory ##

    [[ $PWD = $DEST_REPO ]] && edit_distributions_file
    
    if [[ ! -e ${PWD}/conf/distributions ]] ; then
        mssg_error "El directorio de destino no existe"
        echo
        exit 1
    else
        suitables[${#suitables[@]}]="$(cat ${PWD}/conf/distributions \
        | sed -e '/Codename/!d' -e "/(/d" -e 's/\(Codename: *\)\([[:alnum:]]\+\)/\2/g' )"
    fi

    if [[ -n ${suitables} ]]; then
        for codename in ${suitables[@]} ; do
            if [[ ! -d "${ORIG_PACKAGES}" ]] ; then
                mssg_error "No existe el directorio origen\n\
                            ${ORIG_PACKAGES}"
                echo
                exit 1
            elif [[ ! -d "${ORIG_PACKAGES}/${codename}" ]] ; then
                mssg_error "No existe el directorio origen\n\
                        con la version de paquetes ${BD}'${codename}'${NL}"
                echo
                exit 1
            else
                mssg "${BD}Actualizando${NL} repositorio para ${BD}\"${codename}\"${NL}"
                mssg_ask "${GN}${SCRIPT_NAME}${NL}: Quieres actualizar el repositorio? ${BD}[y/N]${NL}:"
                read -sn1 input_read
                echo
                if [[ "${input_read}" =~ ^[YySs]$ ]] ; then
                    remove_packages ${codename}
                    echo
                    add_packages ${codename}
                else
                    echo
                    mssg_exit
                    echo
                    return 1
                fi
            fi
        done
    else
        mssg_error "No hay versiones el archivo conf/distributions"
        echo
        exit 1
    fi
    echo
    return 0
}


## Crea el punto de montaje en MOUNTPOINT+REMOTE_HOST
function create_mountpoint()
{
    local remote
    
    remote=$(findmnt -t fuse.sshfs | grep "${MOUNTPOINT}" | cut -d " " -f 2)
    mssg "${BD}Creando punto de montaje${NL}"
    if [[ ! -d ${MOUNTPOINT}${REMOTE_HOST} ]] ; then
        mkdir -p ${MOUNTPOINT}${REMOTE_HOST} \
                && mssg "    ${GN}Creando:${NL}${MOUNTPOINT}${REMOTE_HOST}" \
                || mssg_error "No se ha podido crear el punto de montaje."
    else
        
        mssg "     ${GN}Ya exite:${NL} ${MOUNTPOINT}${REMOTE_HOST}"
        if [[ -n "${remote}" ]] ; then
            if [[ "${remote}" = "${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_DESTINATION}" ]]  ; then
                mssg "    con ${remote} ya montado."
            else
                mssg_error "    '${MOUNTPOINT}${REMOTE_HOST}' esta montado pero con otro destino."
                echo
                exit 1
            fi
        fi
    fi
    echo
    return 0
}


## Monta el servidor remoto en el directorio punto de montaje
function mount_remote()
{
    local stat
    
    mountpoint ${MOUNTPOINT}${REMOTE_HOST} > /dev/null
    stat="$?"
    mssg "${BD}Repositorio remoto${NL}"
    
    [[ -n "${IDENTITY}" ]] && IDENTITY=",identityfile=${IDENTITY}"
    mssg "    ${BD}${REMOTE_HOST}:${NL}${BD}${REMOTE_DESTINATION}${NL} puerto ${BD}${REMOTE_PORT}${NL}"
    if [[ "${stat}" != "0" && -d ${MOUNTPOINT}${REMOTE_HOST} ]] ; then
        mssg "    Montando en:${NL}${MOUNTPOINT}${REMOTE_HOST}"
        sshfs ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_DESTINATION} \
            ${MOUNTPOINT}${REMOTE_HOST} -o port=${REMOTE_PORT}${IDENTITY} 
    fi
    mountpoint ${MOUNTPOINT}${REMOTE_HOST} > /dev/null
    stat="$?"
    if [[ "${stat}" = "0" && -d ${MOUNTPOINT}${REMOTE_HOST} ]] ; then
        mssg "    ${GN}Accesible en:${NL} ${MOUNTPOINT}${REMOTE_HOST}"
    else
        mssg_error "No se ha podido montar el host ${BD}${REMOTE_HOST}${NL}"
        echo
        exit 1
    fi
    echo
    return 0
}


## Desmonta el sistema de archivos remoto
function umount_remote()
{
    local remote
    local mounted=$(ls -d -1 ${MOUNTPOINT}* 2> /dev/null)

    mountpoint "$mounted" &> /dev/null
    stat="$?"
    if [[ -n "${mounted}" ]] ; then
        if [[ "${stat}" = "0" ]] ; then
            remote=$(findmnt -t fuse.sshfs | grep "${MOUNTPOINT}" | cut -d " " -f 2)
            mssg "${BD}Repostorio remoto${NL}\n\
                  Desmontando: ${remote}\n\
                  de ${mounted}"
                  
            umount "${mounted}" &&  rm -fR "${mounted}"
        else
            mssg_error "No hay nada montado en\n\
                        $mounted"
            mssg "    ${BD}Eliminando...${NL}"
            echo
            exit 1
        fi
    else
        mssg_error "No existe ningun directorio como punto de montaje"
        echo
        exit 1
    fi
    mssg_exit
    echo
    return 0
}


## Edita el archivo <REPOSITORY_FOLDER>/conf/distributions
function edit_distributions_file()
{
    local file="distributions"
    local input_read=""
    
    mssg "${BD}Editar archivo${NL}"
    if [[ ! -e ./conf/${file} ]] ; then
        mssg_error "El archivo ${BD}${DEST_REPO}/conf/${file}${NL} no existe."
        mssg_ask "${GN}${SCRIPT_NAME}${NL}: Quieres crearlo? ${BD}[y/N]${NL}:"
        read -sn1 input_read
        echo
        if [[ "${input_read}" =~ ^[YySs]$ ]] ; then
            mkdir -p ${DEST_REPO}/conf \
                    && touch ${PWD}/conf/${file} \
                    || (mssg_error "" && exit 0)
            mssg "Creando archivo ${BD}${PWD}/conf/${file}${NL}"
            sleep 0.2
            OLD_IFS=$IFS
            IFS=$'\n'
            for ln in ${DISTRIBUTIONS_TEXT}; do
                echo -e $ln >> ${PWD}/conf/${file}
            done
            IFS=$OLD_IFS
        else
            mssg_exit
            echo
            exit 0
        fi
    fi
    mssg_ask "${GN}${SCRIPT_NAME}${NL}: Quieres editar ${BD}${file}${NL}? ${BD}[y/N]${NL}:"
    read -sn1 input_read
    echo
    if [[ "${input_read}" =~ ^[YySs]$ ]]  ; then
        nano ./conf/${file}
    fi
    echo
    return 0
}


## Guarda las ultimas opciones y argumentos utilizados
function save_lats_options()
{
    mssg "${BD}Guardado opciones y argumentos${NL}\n\
          ${LAST_OPTIONS}"
    [[ ! -e  "${HOME}${OPTS_SAVED_FILE}" ]] && touch  "${HOME}${OPTS_SAVED_FILE}"
    sed -i -e"/^ *$/d"  "${HOME}${OPTS_SAVED_FILE}"  ##  Elimina lineas vacias
    sed -i -e '$a\' "${HOME}${OPTS_SAVED_FILE}"  ## Inserta al final una linea vacia
    sed -i -e '$a\'"${LAST_OPTIONS}" "${HOME}${OPTS_SAVED_FILE}"  ## Inserta linea del texto
    ##  Elimina lineas duplicadas contiguas
    cat "${HOME}${OPTS_SAVED_FILE}" | sort -u -o "${HOME}${OPTS_SAVED_FILE}"  
    [[ $(cat "${HOME}${OPTS_SAVED_FILE}" | wc -l) -gt ${MAX_SAVED} ]] \
                                  && sed -i -e "1d"  "${HOME}${OPTS_SAVED_FILE}"  
    mssg "En ${HOME}${OPTS_SAVED_FILE} "
    echo
    return 0
}


## Muestra las opciones y argumentos gusardados. Opcion -l
function get_last_options()
{
    local input_read
    local n=0
    
    mssg "${BD}Ultimas opciones y argumentos usados${NL}"
    cat "${HOME}${OPTS_SAVED_FILE}" | while read -r line ; do
        n=$(($n + 1))
        mssg " ${BD}${n})${NL} $line"
    done
    mssg " ${BD}*)${NL} Ninguna"
    mssg_ask "${GN}${SCRIPT_NAME}${NL}: Selecciona una opcion: "
    read -sn1 input_read
    echo
    if [[ ${input_read} =~ ^[1-5] ]] ; then
        OPTIONS=$(sed "${input_read}q;d" "${HOME}${OPTS_SAVED_FILE}")
    else
        mssg_exit
        echo
        exit 0
    fi
    echo
    return 0
}

## Muestra mensaje de ayuda
function help_message()
{
    ( cat <<EOF
Description: ${SCRIPT_NAME} updates personal repository.

Usage:
  ${SCRIPT_NAME} [-hlu]
  ${SCRIPT_NAME} -p <SOURCE_PACKAGES> [-r <USER@HOST[:PORT]>] [-i <KEY_FILE>] <REPOSITORY_FOLDER>
  
  Options:
    -h  Shows this message.
    -l  Shows the last 5 sets of passed arguments for choice.
    -u  Umount sshfs remote file system.
    -p  <SOURCE_PACKAGES> Set source packages. (mandatory)
    -r  <USER@HOST.DOMAIN>[:PORT]>
    -i  <KEY_FILE>

  <REPOSITORY_ORIGEN> (mandatory)
    Directory where "reprepro" will create an origen repository
    It must content  afolder called "conf" with at least
    a "distributions" file with the next format:
    
  <SOURCE_PACKAGES>
    Directory that contains a folder for each "codename" with
    all packages we want to add to the repository.
    
  <USER@HOST.DOMAIN[:PORT]>
    User and host in ssh access format.
    
  <KEY_FILE>
    Private key identity file for ssh access.

  <REPOSITORY>/conf/distributions
${DISTRIBUTIONS_TEXT}
EOF
)
}


OPTIONS=$(getopt  -o "hlup:r:i:" -n "${SCRIPT_NAME}" -- "$@")

[ $? != 0 ] && exit 1 

eval set -- "$OPTIONS"

echo
echo -e "${BD}#######  repositorizer  #################${NL}"
echo


while true ; do 
    case $1 in 
            -h)
                help_message
                shift
                exit 0
                ;;
            -l)
                shift
                SAVELAST="n"
                shift
                get_last_options
                eval set -- "$OPTIONS"
                
                ;;
            -p)
                ## Packages origen argumennt
                OPT_P="${1}"
                shift&& 
                if [[ ! ${1} =~ ^-. ]] && [[ ${1} =~ ^[a-zA-Z0-9/]+ ]]; then
                    OPT_ORIGEN="$(realpath ${1})"
                    OPT_P="${OPT_P} '${OPT_ORIGEN}' "
                    shift
                else
                    OPT_P=""
                fi
                ;;
            -r)
                ##  Argument for remote repository
                OPT_R="${1}"
                shift
                if [[ ! ${1} =~ ^-. ]] && [[ ${1} =~ ^[a-zA-Z0-9/]+ ]]; then
                    OPT_REMOTE="${1}"
                    OPT_R="${OPT_R} '${OPT_REMOTE}' "
                    shift
                else
                    OPT_R=""
                fi
                ;;
            -i)
                OPT_I="${1}"
                shift
                if [[ ! ${1} =~ ^-. ]] ; then
                    OPT_IDENTITY="${1}"
                    OPT_I="${OPT_I} '${OPT_IDENTITY}' "
                    shift
                else
                    OPT_I=""
                fi
                ;;
            -u)
                shift
                OPT_UMOUNT="y"
                ;;
            --)
                shift
                
                [[ ${OPT_UMOUNT} ]] && umount_remote && break
                
                [[ -n ${OPT_REMOTE} ]] && validate_remote ${OPT_REMOTE}
                
                [[ -n ${OPT_IDENTITY} && -n ${OPT_REMOTE} ]] && validate_identity ${OPT_IDENTITY}
                
                validate_origen_packages ${OPT_ORIGEN}
                
                OPT_DESTINATION="$( echo ${1} | sed "s|\(^.\+\)[/]$|\1|")"
                shift
                
                if [[ -n ${REMOTE_HOST} ]]; then
                    REMOTE_DESTINATION=$(echo ${OPT_DESTINATION})
                    if [[ ${REMOTE_DESTINATION} ]] ; then
                        create_mountpoint
                        validate_destination_repositori ${MOUNTPOINT}${REMOTE_HOST}
                        mount_remote 
                    else
                        mssg_error "Es necesaria una ruta del host remoto." && exit 0
                    fi
                else
                    OPT_DESTINATION="$(realpath "${OPT_DESTINATION}")"
                    validate_destination_repositori "${OPT_DESTINATION}"
                fi \
                && LAST_OPTIONS="${OPT_P}${OPT_R}${OPT_I}-- '${OPT_DESTINATION}'" \
                && update_repository \
                && [[ ${SAVELAST} = "" ]] && save_lats_options
                #mssg_exit
                break
                ;;
            *)
                shift
                exit 1
                ;;
    esac
done

exit 0

