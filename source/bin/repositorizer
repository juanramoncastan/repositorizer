#!/bin/bash


# repositorizer
# Version: 2.0
# Author: monon


## Script output format variables
SCRIPT_NAME=$(basename $0)
[[ -e ${HOME}/.bash_colors ]] && source ${HOME}/.bash_colors
BD=${BOLD}
NL=${NORMAL}
RD=${RED}
GN=${GREEN}
WARNING="${BD}${RD}Warning!${NL}:"

## Global Variables for "reprepro"
REMOTE_USER=""
REMOTE_HOST=""
REMOTE_PORT=""
REMOTE_DESTINATION=""
DEST_REPO="" ## Carpeta destino del repositorio
ORIG_PACKAGES="" ## Carpeta origen de los paquetes
MOUNTPOINT="/tmp/${USER}/repositorizer_"
OPTS_SAVED_FILE="/.config/repositorizerrc"
MAX_SAVED=5


OPT_REMOTE=""
OPT_ORIGEN=""
OPT_DESTINATION=""

DISTRIBUTIONS_TEXT=$(cat <<EOF

Origin: (domain.org)
Label: (Description label)
Suite: (codename)
Version: (numeral version XX.XX)
Codename: (codename)
Architectures: (amd64 i386 etc)
Components: (main non-free etc)
Description: (Full description)
SignWith: (Last eight digit of key XXXXXXXX)

EOF
)

## Valida 
function validate_remote()
{
    local user
    local host
    local port

    echo
    pattern="^[[[:alnum:]_]+@[[:alnum:]_]+\.[[:alnum:]_]+:[0-9]*$"
    if [[ ! ${1} =~ ^-. ]] && [[ ${1} =~ ${pattern}$ ]]; then
        user=$(echo ${1} | sed -e "s|\(^[[:alnum:]_]\+\)@.*|\1|")
        host=$(echo ${1} | sed -e "s|^.\+@\([[:alnum:]_]\+\.[[:alnum:]_]\+\):.*|\1|")
        port=$(echo ${1} | sed -e  "s|^.\+:\([[:digit:]]\+$\)|\1|g")
        [[ -z $port ]] && port="22"
        REMOTE_USER="${user}"
        REMOTE_HOST="${host}"
        REMOTE_PORT="${port}"
        echo -e "${BD}Host remoto${NL}"
        echo -e "    ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_PORT}"
    else
        echo -ne "${WARNING} "
        echo -e "El host remoto ${BD}${1}${NL} està mal formado"
        echo -e "    Formato: ${BD}user@host.domain:[port]${NL}"
        echo
        exit 1
    fi
    return 0
}


function validate_origen_packages()
{
    echo
    if [[ -z ${1} ]] ; then
        echo -ne "${WARNING} "
        echo -e "Directorio origen de los paquetes no esta definido"
        echo
        exit 1
     elif [[ ! -d ${1} ]]; then
        echo -ne "${WARNING} "
        echo -e "El origen de paquetes no es un directorio"
        echo
        exit 1
     else
        ORIG_PACKAGES="$(realpath ${1})"
        echo -e "${BD}Origen de paquetes${NL}"
        echo -e "    ${ORIG_PACKAGES}"
    fi
    return 0
}


function validate_destination_repositori()
{
    local input_read
    echo
    if [[ -z ${1} ]] ; then  ## If $1 is empty!
        echo -ne "${WARNING} "
        echo -e "Directorio de destino no definido!"
        echo
        exit 1
    else  ## If $1 is not empty
        ## Repositorio destino arguenento (obligatorio sin especificar option option)
        DEST_REPO="$(realpath ${1})"
        [[ $? -eq 0 ]] || exit 1
        ## If $DEST_REPO and /conf directories do not exist!
        if [[ ! -e ${DEST_REPO} ]] ; then
            echo -ne "${WARNING} El directorio "
            echo -e "${BD}${DEST_REPO}${NL} no existe."
            echo -ne "${GN}${SCRIPT_NAME}${NL}: "
            echo -e "Quieres crearlo? [y/N]:"
            read -sn1 input_read
            #echo
            if [[ "${input_read}" =~ ^[YySs]$ ]] ; then
                echo -e "${GN}${SCRIPT_NAME}${NL}: Creando directorio"
                echo -e "    ${DEST_REPO}/conf"
                echo
                mkdir -p ${DEST_REPO}/conf || exit 1
            else
                echo -e "${GN}${SCRIPT_NAME}${NL}: Exiting"
                echo
                exit 0
            fi
        fi
        
        ## If $DEST_REPO exists but it is no a directory
        if [[ ! -d ${DEST_REPO} ]]; then
            echo -ne "${WARNING} "
            echo -e "El destino debe ser un directorio!"
            echo
            exit 1
        else
            #echo -ne "${GN}${SCRIPT_NAME}${NL}: "
            echo -e "${BD}Repositorio destino${NL} (Working directory)"
            echo -e "    ${DEST_REPO}"
            echo
            if [[ ! -n ${ORIG_PACKAGES} ]] && [[ ! -d ${ORIG_PACKAGES} ]]; then
                echo -ne "${WARNING} "
                echo -ne "Directorio origen de los paquetes es incorrecto "
                echo
                exit 1 
            fi
        fi
    fi
    return 0
}


function remove_packages()
{
    local codename=${1}
    local arch="amd64"
    local package_list=$(reprepro -A ${arch} --list-format  '${package} ' list ${codename})
    local package_from_repo
    
    echo -e "${BD}Eliminando${NL} paquetes no referenciados en:"
    echo -e "    ${ORIG_PACKAGES}/${codename}\n"
    for package in ${package_list}  ; do # Itera la lista de "Nombres" de paquetes
        PKG_DEB=$( reprepro -A ${arch} --list-format '${package}_${version}_${architecture}.deb\n' \
                listmatched ${codename} "${package}" | sed -e "s/[0-9]://" ) 
        
        if [[ ! -e "${ORIG_PACKAGES}/${codename}/${PKG_DEB}" ]] ; then 
            echo -e "${BD}${RD}Eliminando del repositorio...${NL}"
            echo -e "${BD}${RD}    ...${PKG_DEB}${NL}"
            reprepro remove ${codename} ${package} > /dev/null
        else
            echo -e "    ${PKG_DEB}"
        fi
    done
    echo
    echo
}


function add_packages()
{
    local codename=${1}
    local command_output
    echo -e "${BD}Añadiendo${NL} paquetes para ${BD}\"${codename}\"${NL} desde:"
    echo -e "    ${ORIG_PACKAGES}/${codename}\n"
    for DEB in ${ORIG_PACKAGES}/${codename}/*.deb ; do 
        DEB=$(echo ${DEB} | sed -e "s/[0-9]://")
        ## Si no funciona añadir  --ask-passphrase
        command_output=$(reprepro -V -A amd64 --ask-passphrase \
            -b . includedeb ${codename} ${DEB}  2> /dev/null \
            || reprepro -V -A amd64 -S utils -P optional --ask-passphrase \
            -b . includedeb ${codename} ${DEB} 2> /dev/null)
        if [[ $(echo -e "${command_output}") =~ Created ]]; then
            echo -e "${GN}Añadiendo...${NL}"
            echo -e "    ${GN}$(basename ${DEB})${NL}"
        else 
            echo -e "    $(basename ${DEB})"
        fi
    done
    echo
    echo
}


function update_repository()
{
    local input_read
    declare -a suitables
    
    cd ${DEST_REPO}

    [[ $PWD = $DEST_REPO ]] && create_distributions_file "distributions"
    
    if [[ ! -e ${PWD}/conf/distributions ]] ; then
        echo -ne "${WARNING} "
        echo -e "El archivo ${BD}distributions${NL} no existe"
        echo
        exit 1
    else
        suitables[${#suitables[@]}]="$(cat ${PWD}/conf/distributions \
        | sed -e '/Codename/!d' -e "/(/d" -e 's/\(Codename: *\)\([[:alnum:]]\+\)/\2/g' )"
    fi

    if [[ -n ${suitables} ]]; then
        for codename in ${suitables[@]} ; do
            echo $codename
            if [[ ! -d "${ORIG_PACKAGES}" ]] ; then
                echo -e "${WARNING} No existe el directorio origen"
                echo -e "    ${ORIG_PACKAGES}"
                exit 1
            elif [[ ! -d "${ORIG_PACKAGES}/${codename}" ]] ; then
                echo -ne "${WARNING} "
                echo -e "No existe el directorio con la version de paquetes"
                echo -e "    ${ORIG_PACKAGES}/${codename}"
                echo
                exit 1
            else
                echo
                #echo -ne "${BD}${GN}${SCRIPT_NAME}${WHITE}: "
                echo -e "${BD}Actualizando repositorio para \"${codename}\"${NL}"
                echo -ne "${GN}${SCRIPT_NAME}${NL}: "
                echo -e "Quieres actualizar el repositorio? [y/N]:"
                read -sn1 input_read
                #echo
                if [[ "${input_read}" =~ ^[YySs]$ ]] ; then
                    # Ejecuta la funcion de eliminar paquetes
                    remove_packages ${codename}
                    # Ejecuta la funcion de inclusion de paquetes
                    add_packages ${codename}
                else
                    echo -e "${GN}${SCRIPT_NAME}${NL}: Exiting"
                fi
            fi
        done
    else
        echo
        echo -e "${WARNING} No hay versiones el archivo conf/distributions"
        echo
        exit 1
    fi
    return 0
}


function create_mountpoint()
{
    if [[ ! -d ${MOUNTPOINT}${REMOTE_HOST} ]]; then
        mkdir -p ${MOUNTPOINT}${REMOTE_HOST}
    fi
}


function error_mounting_remote()
{
    echo -ne "${WARNING} "
    echo -e "No se ha podido montar el host ${BD}${REMOTE_HOST}${NL}"
    exit 0
}


function mount_remote()
{
    local stat
    create_mountpoint
    mountpoint ${MOUNTPOINT}${REMOTE_HOST} > /dev/null
    stat="$?"
    echo -e "${BD}Repostorio remoto"
    echo -e "    ${BD}${REMOTE_DESTINATION}${NL} en ${BD}${REMOTE_HOST}${NL}:${REMOTE_PORT}"
    if [[ "${stat}" != "0" && -d ${MOUNTPOINT}${REMOTE_HOST} ]] ; then
        echo -e "    ${BD}Montando en:${NL} ${MOUNTPOINT}${REMOTE_HOST}"
        sshfs ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_DESTINATION} \
            ${MOUNTPOINT}${REMOTE_HOST} -o port=${REMOTE_PORT} \
            || error_mounting_remote
    fi
    mountpoint ${MOUNTPOINT}${REMOTE_HOST} > /dev/null
    stat="$?"
    if [[ "${stat}" = "0" && -d ${MOUNTPOINT}${REMOTE_HOST} ]] ; then
        echo -e "    ${GN}${BD}Accesible en:${NL} ${MOUNTPOINT}${REMOTE_HOST}"
    fi
    echo
    return 0
}


function umount_remote()
{
    local mounted=$(ls -d -1 ${MOUNTPOINT}*)
    mountpoint "$mounted" > /dev/null
    stat="$?"
    if [[ "${stat}" = "0" ]] ; then
        echo -e "${BD}Repostorio remoto"
        echo -e "    ${BD}${RD}${BD}Desmontando:${NL} ${mounted}"
        umount "${mounted}" &&  rm "${mounted}"
    fi
    echo
    echo -e "${GN}${SCRIPT_NAME}${NL}: Exiting"
    echo
    return 0 
}



function create_distributions_file()
{
    local file=${1}
    local select="y/N"
    local input_read
    if [[ ! -d  ${PWD}/conf ]]; then
        echo -e "Creando directorio ${BD}${PWD}/conf${NL} "
        mkdir -p ${PWD}/conf
    fi
    
    if [[ ! -f ${PWD}/conf/${file} ]]; then
        touch ${PWD}/conf/${file}
        select="Y/n"
        echo -e "Creando archivo ${BD}${PWD}/conf/${file}${NL}"
        sleep 0.2
        OLD_IFS=$IFS
        IFS=$'\n'
        for ln in ${DISTRIBUTIONS_TEXT}; do
            echo -e $ln >> ${PWD}/conf/${file}
        done
        IFS=$OLD_IFS
    else
        echo -e "El archivo ${BD}${file}${NL} existe."
    fi
    echo -ne "${GN}${SCRIPT_NAME}${NL}: Quieres editar ${BD}./conf/${file}${NL}? ${select}:"
    read -sn1 input_read
    #echo
    if [[ "${input_read}" =~ ^[YySs]$ && "$select" = "y/N" ]] || [[ ! "${input_read}" =~ ^[Nn]$ && "$select" = "Y/n" ]] ; then
        nano ./conf/${file}
    fi
}


function save_lats_options()
{
    echo -e "${LAST_OPTIONS}" >> "${HOME}${OPTS_SAVED_FILE}"
    sed -i "/^ *$/d"  "${HOME}${OPTS_SAVED_FILE}"  ##  Elimina lineas vacias
    cat "${HOME}${OPTS_SAVED_FILE}" | sort | uniq > "/tmp/repositoricerrc.tmp"
    [[ -f "/tmp/repositoricerrc.tmp" ]] \
            && cp "/tmp/repositoricerrc.tmp" "${HOME}${OPTS_SAVED_FILE}" \
            && rm "/tmp/repositoricerrc.tmp"

    #sed -i '$!N; /^\(.*\)\n\1$/!P; D' "${HOME}${OPTS_SAVED_FILE}" ##  Elimina lineas duplicadas contiguas
    [[ $(cat "${HOME}${OPTS_SAVED_FILE}" | wc -l) -gt ${MAX_SAVED} ]] && sed -i -e "1d"  "${HOME}${OPTS_SAVED_FILE}"  
}


function get_last_options()
{
    local input_read
    local n=0
    echo -e "${BD}Ultimas argumentos y opciones usados:${NL}"
    cat "${HOME}${OPTS_SAVED_FILE}" | while read -r line ; do
        n=$(($n + 1))
        echo "$n)  $line"
    done
    echo -e "*)  Ninguna"
    echo -ne "${GN}${SCRIPT_NAME}${NL}: Selecciona una opcion:"
    read -sn1 input_read
    #echo
    if [[ ${input_read} =~ ^[1-5] ]] ; then
        OPTIONS=$(sed "${input_read}q;d" "${HOME}${OPTS_SAVED_FILE}")
    else
        echo
        echo -e "${GN}${SCRIPT_NAME}${NL}: Exiting"
        echo
        exit 0
    fi
}


function help_message()
{
    echo -e "repositorizer /path/origen"
    ( cat <<EOF
Description: ${SCRIPT_NAME} builds a .deb package from sources.

Usage:
  ${SCRIPT_NAME} -h
  ${SCRIPT_NAME}   [-s <SOURCE_PACKAGES>] [-c] <REPOSITORY_ORIGEN>
  
  Options:
    -h  Shows this message.
    -s  <SOURCE_PACKAGES> Set source packages.
    -l  Shows for choice the last 5 sets of passed arguments
  
  <SOURCE_PACKAGES>
    Directory that contains a folder for each "codename" with
    all packages we want to add to the repository.
  
  <REPOSITORY_ORIGEN> (mandatory)
    Directory where "reprepro" will create an origen repository
    It must content  afolder called "conf" with at least
    a "distributions" file with the next format:
${DISTRIBUTIONS_TEXT}
EOF
)
}


OPTIONS=$(getopt  -o "hlup:r:" -n "${SCRIPT_NAME}" -- "$@")

[ $? != 0 ] && exit 1 

#LAST_OPTIONS=${OPTIONS}

eval set -- "$OPTIONS"

while true ; do 
    case $1 in 
            -h)
                help_message
                shift
                exit 0
                ;;
            -l)
                shift
                SAVELAST="n"
                shift
                get_last_options
                eval set -- "$OPTIONS"
                echo
                ;;
            -p)
                ## Packages origen argumennt
                OPT_P="${1}"
                shift
                if [[ ! ${1} =~ ^-. ]] && [[ ${1} =~ ^[a-zA-Z0-9/]+ ]]; then
                    OPT_ORIGEN="${1}"
                    OPT_P="${OPT_P} '${1}'"
                    shift
                fi
                ;;
            -r)
                ##  Argument for remote repository
                OPT_R="${1}"
                shift
                if [[ ! ${1} =~ ^-. ]] && [[ ${1} =~ ^[a-zA-Z0-9/]+ ]]; then
                    OPT_REMOTE=${1}
                    OPT_R="${OPT_R} '${1}'"
                    shift
                fi
                ;;
            -u)
                shift
                OPT_UMOUNT="y"
                ;;
            --)
                shift
                
                [[ ${OPT_UMOUNT} ]] && umount_remote && break
                
                [[ -n ${OPT_REMOTE} ]] && validate_remote ${OPT_REMOTE}
                
                validate_origen_packages ${OPT_ORIGEN} && 
                [[ -n ${1} ]] && OPT_DESTINATION=${1}
                shift
                
                if [[ -n ${REMOTE_HOST} ]]; then
                    REMOTE_DESTINATION=${OPT_DESTINATION}
                    create_mountpoint
                    validate_destination_repositori ${MOUNTPOINT}${REMOTE_HOST}
                    mount_remote
                else
                    validate_destination_repositori ${OPT_DESTINATION}
                fi
                LAST_OPTIONS="${OPT_P} ${OPT_R} -- '${OPT_DESTINATION}'"
                
                update_repository && [[ ${SAVELAST} = "" ]] && save_lats_options
                break
                ;;
            *)
                shift
                exit 1
                ;;
    esac
done

exit 0

