#!/bin/bash


# repositorizer
# Version: 2.1
# Author: monon


## Script output format variables
SCRIPT_NAME=$(basename $0)
[[ -e ${HOME}/.bash_colors ]] && source ${HOME}/.bash_colors
BD=${BOLD}
NL=${NORMAL}
RD=${RED}
GN=${GREEN}
WARNING="${BD}${RD}Warning!${NL}:"

## Global Variables for "reprepro"
REMOTE_USER=""
REMOTE_HOST=""
REMOTE_PORT=""
REMOTE_DESTINATION=""
DEST_REPO="" ## Carpeta destino del repositorio
ORIG_PACKAGES="" ## Carpeta origen de los paquetes
MOUNTPOINT="/tmp/${USER}/repositorizer_"
OPTS_SAVED_FILE="/.config/repositorizerrc"
MAX_SAVED=5


OPT_REMOTE=""
OPT_ORIGEN=""
OPT_DESTINATION=""

DISTRIBUTIONS_TEXT=$(cat <<EOF

Origin: (domain.org)
Label: (Description label)
Suite: (codename)
Version: (numeral version XX.XX)
Codename: (codename)
Architectures: (amd64 i386 etc)
Components: (main non-free etc)
Description: (Full description)
SignWith: (Last eight digit of key XXXXXXXX)

EOF
)

function mssg_exit()
{
    echo -e "${BD}Saliendo!${NL}"
}


function mssg_error()
{
    local message=$(echo -e ${1} | sed -e "s|^ \+\(.\+\)|          \1|")
    echo -e "${WARNING} ${message}"
}


function mssg()
{
    local message=$(echo -e "${1}" | sed -e "s|^ \+\(.\+\)$|    \1|")
    echo -e "$message"
}


function mssg_ask()
{
    local message=$(echo -e "${1}" | sed -e "s|^ \+\(.\+\)$|    \1|")
    echo -ne "$message"
}


function validate_remote()
{
    local user
    local host
    local port

    pattern="^[[[:alnum:]_]+@[[:alnum:]_]+\.[[:alnum:]_]+[0-9:]*$"
    if [[ ! ${1} =~ ^-. ]] && [[ ${1} =~ ${pattern}$ ]]; then
        user=$(echo ${1} | sed -e "s|\(^[[:alnum:]_]\+\)@.\+$|\1|")
        host=$(echo ${1} | sed -e "s|^.\+@\([[:alnum:]_]\+\.[[:alnum:]_]\+\)[:][[:digit:]]*|\1|")
        port=$(echo ${1} | sed -e "/.\+:.\+/!d" -e "s|^.\+:\([[:digit:]]*$\)|\1|g")
        [[ -z $port ]] && port="22"
        REMOTE_USER="${user}"
        REMOTE_HOST="${host}"
        REMOTE_PORT="${port}"
        mssg "${GN}${SCRIPT_NAME}${NL}Host remoto\n\
              ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_PORT}"
    else
        mssg_error "El host remoto ${BD}${1}${NL} està mal formado\n\
                    Formato: ${BD}user@host.domain:[port]${NL}"
        echo
        exit 1
    fi
    echo
    return 0
}


function validate_identity()
{
    if [[ -z ${1} ]] ; then
        mssg_error "El archivo clave ssh no esta definido"
        echo
        exit 1
     elif [[ ! -e ${1} ]]; then
        mssg_error "La clave ssh no es valida"
        echo
        exit 1
     else
        IDENTITY="$(realpath ${1})"
        mssg "${BD}Clave ssh${NL}\n\
              ${IDENTITY}"
    fi
    echo
    return 0
}


function validate_origen_packages()
{
    if [[ -z ${1} ]] ; then
        mssg_error "Directorio origen de los paquetes no esta definido"
        echo
        exit 1
     elif [[ ! -d ${1} ]]; then
        mssg_error "El origen de paquetes no es un directorio"
        echo
        exit 1
     else
        ORIG_PACKAGES="$(realpath ${1})"
        mssg "${GN}${SCRIPT_NAME}${NL}: Origen de paquetes\n\
              ${ORIG_PACKAGES}"
    fi
    echo
    return 0
}


function validate_destination_repositori()
{
    local input_read
    
    mssg "${GN}${SCRIPT_NAME}${NL}: Repositorio destino (Working directory)"
    if [[ -n ${1} ]] ; then
        
        if [[ ! -d ${1} ]] ; then 
            mssg_error "Es necesario una ruta al repositorio de destino."
        fi
        DEST_REPO="$(realpath ${1})"

        [[ $? -eq 0 ]] || exit 1

        if [[ ! -e ${DEST_REPO} ]] ; then
            mssg_error "El directorio ${BD}${DEST_REPO}${NL} no existe."
            mssg_ask "Crear directorio? ${BD}[y/N]${NL}:"
            read -sn1 input_read && echo
            if [[ "${input_read}" =~ ^[YySs]$ ]] ; then
                mssg "${GN}${SCRIPT_NAME}${NL}: Creando directorio"
                mkdir -p ${DEST_REPO} || exit 1
            else
                mssg_exit
                exit 0
            fi
        fi

        if [[ ! -d ${DEST_REPO} ]]; then
            mssg_error "El destino debe ser un directorio!"
            echo
            exit 1
        else
            mssg "    ${DEST_REPO}"
            if [[ ! -n ${ORIG_PACKAGES} ]] && [[ ! -d ${ORIG_PACKAGES} ]]; then
                mssg_error "Directorio origen de los paquetes es incorrecto."
                echo
                exit 1 
            fi
        fi
    fi
    echo
    return 0
}


function remove_packages()
{
    local codename=${1}
    local arch="amd64"
    reprepro -A ${arch} --list-format  '${package} ' list ${codename} 1> /dev/null
    if [[ ! ${?} -eq 0 ]] ; then
        mssg_error "Es posible que haya errores de formato en el archivo ${BD}distributions${NL}"
        exit 1
    fi
    local package_list=$(reprepro -A ${arch} --list-format  '${package} ' list ${codename})
    local package_from_repo
     
    mssg "Eliminando paquetes no referenciados en: ${ORIG_PACKAGES}/${codename}\n"
    mssg "Checking..."
    for package in ${package_list}  ; do # Itera la lista de "Nombres" de paquetes
        PKG_DEB=$(reprepro -A ${arch} --list-format '${package}_${version}_${architecture}.deb\n' \
                listmatched ${codename} "${package}" 2> /dev/null | sed -e "s/[0-9]://")
        
        if [[ ! -e "${ORIG_PACKAGES}/${codename}/${PKG_DEB}" ]] ; then 
            mssg "${BD}${RD}Eliminando del repositorio...${NL}\n\
                     ${BD}${RD}    ${PKG_DEB}${NL}"
            reprepro remove ${codename} ${package} > /dev/null
        else
            mssg "    ${PKG_DEB}"
        fi
    done
    return 0
}


function add_packages()
{
    local codename=${1}
    local command_output
    
    mssg "Añadiendo paquetes para ${BD}\"${codename}\"${NL} desde: ${ORIG_PACKAGES}/${codename}\n"
    mssg "Checking..."
    for DEB in ${ORIG_PACKAGES}/${codename}/*.deb ; do 
        DEB=$(echo ${DEB} | sed -e "s/[0-9]://")
        ## Si no funciona añadir  --ask-passphrase
        command_output=$(reprepro -V -A amd64 --ask-passphrase \
            -b . includedeb ${codename} ${DEB}  2> /dev/null \
            || reprepro -V -A amd64 -S utils -P optional --ask-passphrase \
            -b . includedeb ${codename} ${DEB} 2> /dev/null)
        if [[ ! $? -eq 0 ]] ; then
            mssg_error "Es posible que haya errores en el archivo distributions\n\
                                    o  con algun paquete"
            exit 1
        fi
        if [[ $(echo -e "${command_output}") =~ Created ]]; then
            mssg "${GN}Añadiendo...${NL}
                  ${GN}$(basename ${DEB})${NL}"
        else 
            mssg "    $(basename ${DEB})"
        fi
    done
    return 0
}


function update_repository()
{
    local input_read
    declare -a suitables
    
    cd ${DEST_REPO} ## Changing working directory ##

    [[ $PWD = $DEST_REPO ]] && edit_distributions_file "distributions"
    
    if [[ ! -e ${PWD}/conf/distributions ]] ; then
        mssg_error "El directorio de destino no existe"
        echo
        exit 1
    else
        suitables[${#suitables[@]}]="$(cat ${PWD}/conf/distributions \
        | sed -e '/Codename/!d' -e "/(/d" -e 's/\(Codename: *\)\([[:alnum:]]\+\)/\2/g' )"
    fi

    if [[ -n ${suitables} ]]; then
        for codename in ${suitables[@]} ; do
            if [[ ! -d "${ORIG_PACKAGES}" ]] ; then
                mssg_error "No existe el directorio origen\n\
                            ${ORIG_PACKAGES}"
                echo
                exit 1
            elif [[ ! -d "${ORIG_PACKAGES}/${codename}" ]] ; then
                mssg_error "No existe el directorio origen\n\
                        con la version de paquetes ${BD}'${codename}'${NL}"
                echo
                exit 1
            else
                mssg "${GN}${SCRIPT_NAME}${NL}: Actualizando repositorio para ${BD}\"${codename}\"${NL}"
                mssg_ask "Quieres actualizar el repositorio? ${BD}[y/N]${NL}:"
                read -sn1 input_read && echo
                if [[ "${input_read}" =~ ^[YySs]$ ]] ; then
                    remove_packages ${codename}
                    echo
                    add_packages ${codename}
                else
                    echo
                    mssg_exit && return 1
                fi
            fi
        done
    else
        mssg_error "No hay versiones el archivo conf/distributions"
        echo
        exit 1
    fi
    echo
    return 0
}


function create_mountpoint()
{
    local remote
    
    remote=$(findmnt -t fuse.sshfs | grep "${MOUNTPOINT}" | cut -d " " -f 2)
    mssg "${GN}${SCRIPT_NAME}${NL}: Creando punto de montaje"
    if [[ ! -d ${MOUNTPOINT}${REMOTE_HOST} ]] ; then
        mkdir -p ${MOUNTPOINT}${REMOTE_HOST} \
                && mssg "    ${GN}Creando:${NL}${MOUNTPOINT}${REMOTE_HOST}" \
                || mssg_error "No se ha podido crear el punto de montaje."
    else
        
        mssg "     ${GN}Ya exite:${NL} ${MOUNTPOINT}${REMOTE_HOST}"
        if [[ -n "${remote}" ]] ; then
            if [[ "${remote}" = "${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_DESTINATION}" ]]  ; then
                mssg "    con ${remote} ya montado."
            else
                mssg_error "    '${MOUNTPOINT}${REMOTE_HOST}' esta montado pero con otro destino."
                echo
                exit 1
            fi
        fi
    fi
    echo
    return 0
}


function mount_remote()
{
    local stat
    
    mountpoint ${MOUNTPOINT}${REMOTE_HOST} > /dev/null
    stat="$?"
    mssg "${BD}Repositorio remoto"
    
    [[ -n "${IDENTITY}" ]] && IDENTITY=",identityfile=${IDENTITY}"
    mssg "    ${BD}${REMOTE_HOST}:${NL}${BD}${REMOTE_DESTINATION}${NL} puerto ${BD}${REMOTE_PORT}${NL}"
    if [[ "${stat}" != "0" && -d ${MOUNTPOINT}${REMOTE_HOST} ]] ; then
        mssg "    ${BD}Montando en:${NL}${MOUNTPOINT}${REMOTE_HOST}"
        sshfs ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_DESTINATION} \
            ${MOUNTPOINT}${REMOTE_HOST} -o port=${REMOTE_PORT}${IDENTITY} 
    fi
    mountpoint ${MOUNTPOINT}${REMOTE_HOST} > /dev/null
    stat="$?"
    if [[ "${stat}" = "0" && -d ${MOUNTPOINT}${REMOTE_HOST} ]] ; then
        mssg "    ${GN}Accesible en:${NL} ${MOUNTPOINT}${REMOTE_HOST}"
    else
        mssg_error "No se ha podido montar el host ${BD}${REMOTE_HOST}${NL}"
        echo
        exit 1
    fi
    echo
    return 0
}


function umount_remote()
{
    local remote
    local mounted=$(ls -d -1 ${MOUNTPOINT}* 2> /dev/null)

    mountpoint "$mounted" &> /dev/null
    stat="$?"
    if [[ -n "${mounted}" ]] ; then
        if [[ "${stat}" = "0" ]] ; then
            remote=$(findmnt -t fuse.sshfs | grep "${MOUNTPOINT}" | cut -d " " -f 2)
            mssg "${GN}${SCRIPT_NAME}${NL}: Repostorio remoto\n\
                  Desmontando: ${remote}\n\
                  de ${mounted}"
                  
            umount "${mounted}" &&  rm -fR "${mounted}"
        else
            mssg_error "No hay nada montado en\n\
                        $mounted"
            mssg "    ${BD}Eliminando...${NL}"
            echo
            exit 1
        fi
    else
        mssg_error "No existe ningun directorio como punto de montaje"
        echo
        exit 1
    fi
    mssg_exit
    echo
    return 0
}


function edit_distributions_file()
{
    local input_read=""
    local file=${1}
    
    mssg "${GN}${SCRIPT_NAME}${NL}: Editar archivo"
    if [[ ! -e ./conf/${file} ]] ; then
        mssg_error "El archivo ${BD}${DEST_REPO}/conf/${file}${NL} no existe."
        mssg_ask "Quieres crearlo? ${BD}[y/N]${NL}:"
        read -sn1 input_read && echo
        if [[ "${input_read}" =~ ^[YySs]$ ]] ; then
            mkdir -p ${DEST_REPO}/conf \
                    && touch ${PWD}/conf/${file} \
                    || (mssg_error "" && exit 0)
            mssg "Creando archivo ${BD}${PWD}/conf/${file}${NL}"
            sleep 0.2
            OLD_IFS=$IFS
            IFS=$'\n'
            for ln in ${DISTRIBUTIONS_TEXT}; do
                echo -e $ln >> ${PWD}/conf/${file}
            done
            IFS=$OLD_IFS
        else
            mssg_exit
            exit 0
        fi
    fi
    mssg_ask "Quieres editar ${BD}${file}${NL}? ${BD}[y/N]${NL}:"
    read -sn1 input_read && echo
    if [[ "${input_read}" =~ ^[YySs]$ ]]  ; then
        nano ./conf/${file}
    fi
    echo
    return 0
}


function save_lats_options()
{
    mssg "${GN}${SCRIPT_NAME}${NL}: Guardado opciones y argumentos\n\
          ${LAST_OPTIONS}"
    sed -i "/^ *$/d"  "${HOME}${OPTS_SAVED_FILE}"  ##  Elimina lineas vacias
    sed -i -e '$i\' "${HOME}${OPTS_SAVED_FILE}"
    sed -i -e '$i\'"${LAST_OPTIONS}" "${HOME}${OPTS_SAVED_FILE}"
    #echo -e "${LAST_OPTIONS}" >> "${HOME}${OPTS_SAVED_FILE}"
    
    cat "${HOME}${OPTS_SAVED_FILE}" | sort | uniq > "/tmp/repositoricerrc.tmp"
    [[ -f "/tmp/repositoricerrc.tmp" ]] \
            && cp "/tmp/repositoricerrc.tmp" "${HOME}${OPTS_SAVED_FILE}" \
            && rm "/tmp/repositoricerrc.tmp"
    #sed -i '$!N; /^\(.*\)\n\1$/!P; D' "${HOME}${OPTS_SAVED_FILE}" ##  Elimina lineas duplicadas contiguas
    [[ $(cat "${HOME}${OPTS_SAVED_FILE}" | wc -l) -gt ${MAX_SAVED} ]] \
                                  && sed -i -e "1d"  "${HOME}${OPTS_SAVED_FILE}"  
    echo
    return 0
}


function get_last_options()
{
    local input_read
    local n=0
    
    mssg "${GN}${SCRIPT_NAME}${NL}: Ultimas opciones y argumentos usados"
    cat "${HOME}${OPTS_SAVED_FILE}" | while read -r line ; do
        n=$(($n + 1))
        mssg " ${BD}${n})${NL} $line"
    done
    mssg " ${BD}*)${NL} Ninguna"
    mssg_ask "${GN}${SCRIPT_NAME}${NL}: Selecciona una opcion: "
    read -sn1 input_read && echo
    if [[ ${input_read} =~ ^[1-5] ]] ; then
        OPTIONS=$(sed "${input_read}q;d" "${HOME}${OPTS_SAVED_FILE}")
    else
        mssg_exit && exit 0
    fi
    echo
    return 0
}


function help_message()
{
    ( cat <<EOF
Description: ${SCRIPT_NAME} updates personal repository.

Usage:
  ${SCRIPT_NAME} [-hlu]
  ${SCRIPT_NAME} -p <SOURCE_PACKAGES> [-r <USER@HOST>] [-i <FILE>] <REPOSITORY_FOLDER>
  
  Options:
    -h  Shows this message.
    -l  Shows for choice the last 5 sets of passed arguments.
    -u  Umount sshfs remote file system.
    -p  <SOURCE_PACKAGES> Set source packages. (mandatory)
    -r  <USER@HOST.domain>[:PORT]
    
  
  <SOURCE_PACKAGES>
    Directory that contains a folder for each "codename" with
    all packages we want to add to the repository.
  
  <REPOSITORY_ORIGEN> (mandatory)
    Directory where "reprepro" will create an origen repository
    It must content  afolder called "conf" with at least
    a "distributions" file with the next format:
${DISTRIBUTIONS_TEXT}
EOF
)
}


OPTIONS=$(getopt  -o "hlup:r:i:" -n "${SCRIPT_NAME}" -- "$@")

[ $? != 0 ] && exit 1 

eval set -- "$OPTIONS"

echo
echo -e "${BD}#######  repositorizer  #################${NL}"
echo


while true ; do 
    case $1 in 
            -h)
                help_message
                shift
                exit 0
                ;;
            -l)
                shift
                SAVELAST="n"
                shift
                get_last_options
                eval set -- "$OPTIONS"
                
                ;;
            -p)
                ## Packages origen argumennt
                OPT_P="${1}"
                shift&& 
                if [[ ! ${1} =~ ^-. ]] && [[ ${1} =~ ^[a-zA-Z0-9/]+ ]]; then
                    OPT_ORIGEN="${1}"
                    OPT_P="${OPT_P} '${1}'"
                    shift
                fi
                ;;
            -r)
                ##  Argument for remote repository
                OPT_R="${1}"
                shift
                if [[ ! ${1} =~ ^-. ]] && [[ ${1} =~ ^[a-zA-Z0-9/]+ ]]; then
                    OPT_REMOTE=${1}
                    OPT_R="${OPT_R} '${1}'"
                    shift
                fi
                ;;
            -i)
                OPT_I="${1}"
                shift
                if [[ ! ${1} =~ ^-. ]] ; then
                    OPT_IDENTITY=${1}
                    OPT_I="${OPT_I} '${1}'"
                    shift
                fi
                ;;
            -u)
                shift
                OPT_UMOUNT="y"
                ;;
            --)
                shift
                
                [[ ${OPT_UMOUNT} ]] && umount_remote && break
                
                [[ -n ${OPT_REMOTE} ]] && validate_remote ${OPT_REMOTE}
                
                [[ -n ${OPT_IDENTITY} && -n ${OPT_REMOTE} ]] && validate_identity ${OPT_IDENTITY}
                
                validate_origen_packages ${OPT_ORIGEN}
                
                OPT_DESTINATION=${1}
                shift
                
                if [[ -n ${REMOTE_HOST} ]]; then
                    REMOTE_DESTINATION=${OPT_DESTINATION}
                    if [[ ${REMOTE_DESTINATION} ]] ; then
                        create_mountpoint
                        validate_destination_repositori ${MOUNTPOINT}${REMOTE_HOST}
                        mount_remote 
                    else
                        mssg_error "Es necesaria una ruta del host remoto." && exit 0
                    fi
                else
                    validate_destination_repositori ${OPT_DESTINATION} \
                    && OPT_DESTINATION=$(realpath ${OPT_DESTINATION})
                fi \
                && LAST_OPTIONS="${OPT_P} ${OPT_R} ${OPT_I} -- '${OPT_DESTINATION}'" \
                && update_repository \
                && [[ ${SAVELAST} = "" ]] \
                && save_lats_options \
                && mssg_exit
                break
                ;;
            *)
                shift
                exit 1
                ;;
    esac
done

exit 0

